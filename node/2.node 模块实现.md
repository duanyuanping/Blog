## # node 模块实现

node 引入模块有一下三个步骤：

1. 路径分析
2. 文件定位
3. 编译执行

node 中的模块分成两类：核心模块（node 编写）、文件模块（用户编写）

部分 node 核心模块会在编译过程时，编译进二进制执行文件。node 进程启动时，部分核心模块会被直接加载进内存中。在应用中引入这部分的模块就会省略掉路径分析和文件定位，因此它的加载速度是最快的。

文件模块运行时动态加载，就需要经历路径分析、文件定位、编译执行这三个步骤，速度比核心模块慢。

模块加载顺序：

- 缓存
- 核心模块
- 文件模块

## 路径分析

require() 方法接收一个标识符作为参数，标识符分成如下：

- 核心模块，如 http、fs、path等
- . 或者 .. 相对路径引入的文件模块
- 使用 / 开始的绝对路径
- 非路径形式的文件模块（自定义模块），如自定义模块 axios 等

### 核心模块

核心模块的加载优先级比缓存要低。当如果有自定义模块的加载标识符和核心模块的加载标识符一样的时候，自定义模块会加载失败。

### 路径形式的文件模块

require() 方法会将路径转为真实的路径，并以真实的路径作为索引，将编译执行后的结果存放到缓存中，以便第二次加载更快。

![1554707243660](C:\Users\mackenike\AppData\Roaming\Typora\typora-user-images\1554707243660.png)

### 自定义模块

这类模块加载最耗时，是所有模块加载最慢的一种。下面展示这种模块资源查找的步骤：

#### 模块路径生成

![1554707604571](C:\Users\mackenike\AppData\Roaming\Typora\typora-user-images\1554707604571.png)

模块路径生成规则：

- 当前文件目录下的 node_modules 目录
- 父目录下的 node_modules 目录
- 父目录的父目录的 node_modules 目录
- 以此向上逐级递归，直到找到根目录下的 node_modules 目录

文件路径越深，模块查找耗时就越多，这是自定义模块的加载速度最慢的原因

## 文件定位

### 文件拓展名分析

commonjs 允许在标识符中不包含文件拓展名，node 会按 .js、.json、.node 的顺序补足扩展名，node 在尝试过程中会使用到 fs 模块同步阻塞的判断文件是否存在，由于 node 是单线程，所以这里就会引起性能问题。因此，如果文件的拓展名为 .json、.node 时就最好将文件后缀带上。

### 目录分析

require() 通过分析文件扩展名之后，可能只是找到了一个目录。此时，node 就会读取当前目录下的 package.json 文件（通过 JSON.parse()），从中获取 main 属性指定的文件名进行定位，如果 main 指定的文件名错误或者没有 package.json 文件，node 会将 index 当成默认的文件名。

## 模块编译

每一个文件模块都是一个由 Module 实例出来的对象。每一个编译成功的模块都会以文件路径作为索引缓存到 `require.cache` 中。

在写文件模块代码时我们没有提供 module、exports、require、__ filename、__ dirname 这些变量，但是在实际写代码时我们又可以直接访问到。这是因为在编译过程中， node 对获取的 js 文件内容会进行头尾报装。