# 不同一级域名下的单点登录

## 简述

如果一个团队中有多个产品，并且想要让用户在某一个系统中进行登录之后，其他的系统都处于登录状态的需求；如果有一个系统退出，所有系统都要退出登录。上面的业务场景的需求就是单点登录。

如果团队中的系统在同一个一级域名下面，那就不需要使用下面所展示的单点登录逻辑。

本篇展示的单点登录是使用独立用户登录中心系统的方式来实现的，具体流程后面会给出时序图来尽心展示。

![1539781787910](C:\Users\mackenike\AppData\Roaming\Typora\typora-user-images\1539781787910.png)

## 使用中间件

由于所有的业务后端都需要请求登录中心后端询问用户是否处于登录状态、将用户登录信息存入本本系统后端、同时退出登录、用户未登录返回相同的数据。

这些功能都一样，所以我需要将他提成一个组件，所以我们单点登录的代码就是使用的 eggjs 的中间件，这里使用 magicSSO 命名这个中间件。

中间件 magicSSO 配置中，我们用户登录中心系统的域名、本业务系统退出登录的 path 放入配置项中。

将登录中心域名放入配置的原因是，如果修改了登录中心的域名，我们可以很快的在配置项中修改，但是如果没有提成配置，就得去找 magicSSO 代码中哪里用了登录中心域名，更何况我们这里将 magicSSO 中间将弄成 一个包发布到 npm。

将本业务系统退出登录的路由路径放入配置，这样可以让每个系统都能够有自己的一套路由路径不用被登录这个所局限。

```
// magicSSO 配置
module.exports = () => {
  const config = {
    magicSSO: {
      domain: 'http://localhost:7010', // 用户登录中心系统域名
      logoutPath: '/api/logout', // 子应用中退出登录的路由路径
      enable: true, // 控制中间件是否开启。
      // 自行配置 match 或者 ignore 来满足自己的业务
    },
    middleware: [ 'magicSSO' ]
  }
  return config；
}；
```

## 中间件 magicSSO

magicSSO 需要完成的工作有：

- 生成 token
- 检验用户是否登录（检验用户在本系统后端有登录信息和请求用户登录中心后台检测用户登录状态接口）
- 接收并处理业务前端的退出登录请求
- 接收删除本系统后台存储的用户登录信息

由于会使用到 redis，所以用户在写配置文件的时候需要将 redis 账号这些信息都配置好，不然后面就没法存放用户登录信息。

### 生成 token

业务系统后端存放用户登录信息的方式是以 token 为键用户的信息为值得形式存入 redis 数据库中，token 是对 ip 和 user-agent 加密后的值。

```
const normalizeUrl = require('normalize-url');
const axios = require('axios');
const crypto = require('crypto');
const ms = require('ms');
const sessionMaxAge = ms('0.5h'); // 用户登录状态过期时间为 30 分钟

const unLoginBody = {
  code: '200001',
  msg: '用户未登录',
};

const userOnly = (ip, agent) => {
  return crypto.createHash('sha256').update(ip + agent).digest('hex');
};

module.exports = (options, app) => {
  return async function magicSSO(ctx, next) {
  	let ip = ctx.ip;
    ip = ip.indexOf('::ffff:') !== -1 ? ip.split('::ffff:')[1] : ip === '::1' ? '127.0.0.1' : ip;
    const agent = req.headers['user-agent'];
    // 加密 ip 和 agent
    const token = userOnly(ip, agent);
    // 其他单点登录业务的处理，后面所展示的代码全部属于 magicSSO 函数里面的内容
  	......
  }
};
```



### 检验用户是否登录

我们先从 redis 数据库中获取键值等于 token 的数据。如果有，就表示用户登录了的，将执行权限交给业务处理代码；如果没有，我们就需要去请求用户登录中心系统提供的检测用户登录状态的接口来获取用户是否登录。代码如下：

```
// 从 redis 数据库中获取用户登录信息
const user = typeof app.redis.get === 'function' && await app.redis.get(token);
if (user) {
  await next();
  // 刷新此用户的登录信息的时间
  typeof app.redis.set === 'function' && await app.redis.set(token, user, 'PX', sessionMaxAge);
} else {
  // 请求用户登录中心后端提供的检测用户登录信息的接口
  const res = await axios({
    method: 'get',
    url: normalizeUrl(`${options.domain}/api/checkUser?token=${token}`),
    // 登录中心需要将拥有用户登录信息的系统记录下来，所以这里将本业务系统的后端 host 传给登录中心
    headers: {
      referer: ctx.header.host
    },
  });
  if (parseInt(res.data.code) === 100001) {
    // 如果登录中心系统检测出用户是登录了的，就把用户的信息返回给本系统，然后将用户登录信息在本系统中也存放一份
    typeof app.redis.set === 'function' && await app.redis.set(token, JSON.stringify(res.data.data), 'PX', sessionMaxAge);
    await next();
    logger.info(`varbee-sso: 鉴权成功 ====== ${token}`);
  } else {
    // 如果没有登录或者登录中心系统处理出了问题，就返回给前端用户未登录的状态
    ctx.body = unLoginBody;
  }
}
```

### 接收并处理业务前端的退出登录请求

当某一个系统的前端发起退出登录的请求，那么就需要请求登录中心提供的登出接口，让登录中心和其他存有用户登录信息的系统也删除用户信息，如果登录中心系统成功登出，那么此系统后端就需要删除用户登录信息。

```
// 如果前端请求路径是本系统后台设置的登出路由
if (ctx.path === options.logoutPath) {
  // 请求登录中心后台提供的登出接口
  const res = await axios({
    method: 'get',
    url: normalizeUrl(`${options.domain}/api/logout?token=${token}`)
  });
  if (parseInt(res.data.code) === 100001) {
  	// 如果登录中心成功登出，就删除本系统中的用户登录信息，并且响应前端未登录的状态码
    typeof app.redis.del === 'function' && await app.redis.del(token);
    ctx.body = unLoginBody;
    logger.info(`varbee-sso: 退出登录成功 ====== ${token}`);
  } else {
    // 登录中心登出失败，就将失败的原因返回给前端
    logger.info(`varbee-sso: 退出登录失败 ====== ${token}`);
    ctx.body = res.data;
  }
  return;
}
```

### 接收删除本系统后台存储的用户登录信息

当其他系统向登录中心系统发起登出请求的时，中心系统会想已经单独存放用户登录信息的系统发起登出请求，所以每个系统都需要有接收中心系统发出的登出操作。

那么登录中心系统是怎么知道到底有哪些系统单独存放了用户登录信息了呢？

还记得前面我们请求登录中心系统提供的检测中心系统是否含有此用户的登录信息的接口时再请求头中写入的 referer 字段吗？这个接口实际完成的工作不仅仅只是判断用户是否登录，当我们请求他的时候，他会将请求头中的 referer 字段存放到用户登录信息中，这样就能够在后面对这些系统统一发起退出操作了。

```
// 提供给登录中心请求的登出路径
if (ctx.path === '/sso/delete/session') {
  const userToken = ctx.query.token;
  typeof app.redis.del === 'function' && await app.redis.del(userToken);
  ctx.body = { code: '100001', msg: '操作成功' };
  return;
}
```

## 登录中心

这里只会展示关于单点登录有关的代码，对于用户登录是否输入正确的账号和密码什么这些登录业务的代码，在前面 [用户登录中心系统](https://github.com/duanyuanping/True-in-Hong/blob/master/node/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%B8%AD%E5%BF%83%E7%B3%BB%E7%BB%9F.md) 中已经展示了差不多的登录逻辑，只是存放用户登录信息的方式不同而已，后面会写一些。

### 登录接口

登录前端页面请求登录接口，用户输入比对成功后，获取用户前端的 ip 和浏览器版本 user-agent，对他们进行加密生成 token，加密的方式和实现单点登录的中间件加密方式必须一样。然后以 token 为键，用户基本信息和 logined 属性为值，存入 redis 中。这里的 logined 是一个数组，用来存放哪些系统单独拥有用户登录信息。

### 检测用户是否登录

```
async checkUser() {
  const { ctx, app } = this;
  const { logger, request, header: { referer } } = ctx;
  // 其他系统请求此接口的时候需要带上 token
  const { token } = request.query;

  try {
  	// 获取 redis 数据库中键为 token 的信息
    let user = await app.redis.get(token);
    // 如果没有此用户信息，就返回未登录
    if (!user) {
    	// response 函数是自己封装的函数，根据 code 来匹配出事先设置的 msg
      this.response({ code: 200001 });
      return;
    }
    user = JSON.parse(user);
    // 有这个用户的登录信息，就像此用户信息中的 logined 数组中添加 referer
    user.logined.push(referer);
    // 更新 redis 数据库中的用户登录信息和时间
    await app.redis.set(token, JSON.stringify(user), 'PX', sessionMaxAge);
    // 用户信息中的 logined 字段删除，并在响应请求的时候带上处理过后的用户信息
    Reflect.deleteProperty(user, 'logined');
    this.response({ data: user, code: 100001 });
  } catch (error) {
  	// 错误处理
    logger.error(`checkUser-${error}`);
    this.response({ code: 300004 });
  }
}
```

### 登出

```
const normalizeUrl = require('normalize-url');
const axios = require('axios');

async logout() {
  const { ctx, ctx: { request, logger } } = this;
  // 获取用户的 token，请求此接口的时候也需要带上 token
  const { token } = ctx.query;

  try {
  	// 获取用户的登录信息
    const user = await app.redis.get(token);
    // 如果有此用户的登录信息，就像遍历 logined 数组中存放的系统地址，让其他存有此用户登录信息的系统删除掉此用户登录信息
    if (user) {
      const { logined } = JSON.parse(user);
      // 这里我觉得不需要等待返回结果
      logined.map(url => {
        axios({
          method: 'get',
          url: normalizeUrl(`${url}/sso/delete/session?token=${token}`),
        });
      });
      // 删除登录中心系统中的此用户登录信息
      await app.redis.del(token);
      logger.info(`magic sso: ${token} logout`);
    }
    this.response({ code: 100001 });
  } catch (error) {
    logger.error(`magic-sso: logout ====== ${error}`);
    this.response({ code: 300004 });
  }
}
```

差不多单点登录系统的步骤介绍到这就结束了。最后再说下，如果需要做单点登录系统的前端页面全部在同一个一级域名下，就不需要使用用户的 ip 和 agent 只需要将 cookie 写入一级域名下，就能能通过 nodejs 提供的 session 池来完成单点登录的工作。后面应该会将在同一一级域名的单点登录展示出来。