文中内容摘自 https://zhuanlan.zhihu.com/p/26027085（如果误入请查看原文）

## 同步更新的局限

react16 之前，组件更新过程是同步的。

当 react 加载或者更新组件树时会做很多事情，如调用组件的生命周期、计算和比较 Virtual DOM，然后更新 DOM 树，这一系列过程都是同步进行的。react 一旦开启加载或更新组件后，就会一直占用 js 主线程直到 DOM 加载或更新完成。

加入更新一个组件消耗 1 毫秒，如果有 200 个组件需要更新，那么在这 200 毫秒里面，浏览器主线程除了更新组件，其他事情都无法处理。如果在更新过程中，用户向 input 框中输入内容，在 200 个组件更新完成之前 input 框中都不会有用户输入的内容，直到组件更新完成，input 框中就会一下出现用户输入的内容，这样就会给用户页面卡顿的印象，用户体验不好。

在使用 react fiber 前，组件一层层的箱套在一起，函数的调用栈如下图一样：

![](https://pic1.zhimg.com/80/v2-d8f4598c70df94d69825f11dfbf2ca2c_hd.png)

## react fiber 的方式

破解JavaScript中同步操作时间过长的方法——分片。

把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。

React Fiber把更新过程碎片化，执行过程如下面的图所示，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。

![](https://pic1.zhimg.com/80/v2-78011f3365ab4e0b6184e1e9201136d0_hd.png)

## react fiber 对现有代码的影响

在React Fiber中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会**完全作废，然后等待机会重头再来**。

react fiber 更新过程分为两个阶段：一个阶段Reconciliation Phase和第二阶段Commit Phase。

在第一阶段Reconciliation Phase，React Fiber会找出需要更新哪些DOM，这个阶段是可以被打断的；但是到了第二阶段Commit Phase，那就一鼓作气把DOM更新完，绝不会被打断。

![](https://pic2.zhimg.com/80/v2-d2c7de3c408badd0abeef40367d3fb19_hd.png)

因为第一阶段的过程会被打断而且“重头再来”，就会造成意想不到的情况。

比如说，一个低优先级的任务A正在执行，已经调用了某个组件的componentWillUpdate 函数，接下来发现自己的时间分片已经用完了，于是冒出水面，看看有没有紧急任务，哎呀，真的有一个紧急任务B，接下来React Fiber就会去执行这个紧急任务B，任务A虽然进行了一半，但是没办法，只能完全放弃，等到任务B全搞定之后，任务A重头来一遍，注意，是重头来一遍，不是从刚才中段的部分开始，也就是说，componentWillUpdate 函数会被再调用一次。