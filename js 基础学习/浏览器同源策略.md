# 浏览器同源策略

## 简述

同源是指协议、域名（或者 ip）、端口这三者相同的网址之间是同源的。

下面是一个与 http://www.example.com/page/index.html 的同源检测表：

| url                                       | 是否同源 | 原因         |
| ----------------------------------------- | -------- | ------------ |
| http://www.example.com/goods/car.html     | 是       |              |
| https://www.example.com/page/index.html   | 否       | 协议不同     |
| http://manage.example.com/page/index.html | 否       | 三级域名不同 |
| http://www.example.com:81/page/index.html | 否       | 端口不同     |

浏览器开发同源策略的目的是防止恶意网站窃取用户信息，引入廖雪峰博文中的例子如下：

用户使用浏览器进入银行系统（A）后进行了用户登录后，等他把他要弄的业务弄完了以后，他将将银行网页窗口直接关了，并没有用户登出，如果在存放登录状态的 cookie 过期前，他进入了一个恶意窃取信息的网站（B），那么 B 就能够冒充用户向银行系统后台请求用户的信息，这样用户信息就会泄露。

## 限制

浏览器同源策略使得 cookie、LocalStorage、IndexDB、ajax、dom 这几类的操作受到限制。下面将会讲解 cookie、ajax 这两类如何解决同源的限制，LocalStorage、IndexDB 和 dom 操作在后面我学习后在补充。 

## cookie

因为同源策略的原因，不同源的页面无法获取对方的 cookie。但是三级域名能够访问到二级域名下的所有 cookie，我们可以利用这一点来实现不同源但是二级域名一样的页面 cookie 共享。下面将展示一个例子：

我们有 http://www.example.com 和 http://manage.example.com 两个页面，我们想要在 www 页面中设置的 cookie 在 manage 页面中也能够访问到：

```
document.cookie = 'num=123;domain=.example.com'; // 注意这里是 .example.com 不是 example.com
```

上面的代码会将这个 cookie 写到 `.examle.com` 上面，这样 manage 页面也能够访问到 name 为 num 的 cookie。

不只是前端可以设置 cookie 属于哪个域名，后端也可以设置 cookie 的 domain 参数，如下图：

![1539953980231](https://github.com/duanyuanping/True-in-Hong/tree/master/static/1539953980231.png)

服务器这样设置 cookie 的 domain 以后不管是 www 还是 manage 页面都能够访问到此 cookie。

## ajax

跨域 Ajax 请求不能发送，服务器端收到请求的原因是浏览器在向跨域服务器请求数据前会向服务器发起一个 options 请求来确定服务器是否允许跨域请求。这里不管是 get 还是 post 还是其他请求方式，浏览器在正式请求数据前都会发送一个类型为 options 的请求。

ajax 解决跨域的办法有很多，例如：JSONP、CORS、WebSocket、代理转发，这里就只是展示 JSONP、反向代理转发这两种解决办法。CORS 是后端解决跨域的一种方法，后面会单独写一篇，也可以到廖雪峰的 [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html) 进行对 CORS 的学习。我到现在还没怎么解触 WebSocket 方面的学习，等学习了再展示解决方法。

### JSONP

JSONP 利用的是 html 中的 script 标签，因为 script 请求资源不会受到同源策略的影响，所以我们可以在 script 标签中的 src 属性的值设置为我们想要请求的数据的地址并且地址后面带上 `?callback=foo` （其实就是处理返回的数据的函数名），然后由服务器返回犹如调用函数的形式的字符串，这样 script 收到这个字符串后会直接将他当成 js 语句来执行，有一点需要注意的是 JSONP 只能用于 get 请求，其他的都不行。

如下：

```
// 前端
const request = url => {
  const script = document.createElement('script');
  script.type = 'text/javascript';
  script.src = url;
  document.body.appendChild(script);
}
const foo = data => {
  console.log(data);
}
const btn = document.getElementById('btn');
btn.onclick = () => {
  request('http://localhost:7010/api/checkUser?callback=foo')
}
```

后端只需要返回 `foo({ name: 'duan' })` 这样的字符串就行了。

后面实际操作的时候浏览器一直报 Cross-Origin Read Blocking (CORB) 保护，去查了下 CORB 保护启动主要会在服务器响应的内容格式为 json、html、xml 时启动，所以后端只需要修改响应头中的 content-type。这里因为是使用 jsonp 解决跨域，所以 content-type 设置为 application/x-javascript;charset=utf-8，就能够避开浏览器的 CORB 保护。如果想要学习 CORB，我是到 https://juejin.im/post/5b7e826ee51d4538b35c04e8#comment 这个网站进行学习的。

### 反向代理

这里主要介绍两种方法：

1. 使用 webpack 中的 webpack-dev-server 插件实现代理
2. 使用 Nginx 代理

这里先列出来，我还没有具体去深入学习，先展示一部分代码，后面学一部分后就马上来填充

1、webpack-dev-server

多用于开发开发

```
module.exports = {
  entry: {},
  output: {},
  devServer: {
    ...,
    port: '8080',
    proxy: {
    	// 匹配 '/api' 含有
      '/api': {
        target: 'http://localhost:7001/api', // 想要被代理到那个服务器的域名或者 ip 后面可以跟路径
        pathRewrite: {'^/api' : ''}, // 对匹配的路径重写
      }
    }
  }
}
```

2、nginx

多用于生产环境，下面只展示常用的几个（我还没有系统的学习 Nginx 配置，等过几天学了再来补充）

```
server {
  listen 80; // 这里是监听的本服务器的端口（80：http 文本传送；443：https）
  server_name: localhost; // 匹配的域名（localhost 为全部都能匹配上，这里如果想只有 http://www.example.com 才能匹配上的话就把 localhost 改成 www.example.com 就行了）
  ...
  location / { // 匹配根路径
    root /home/workspace/blog; // 文件路径
    index index.html index.html;
  }
  location /api/ {
  	proxy_pass http://localhost:7001/api/; // 这里将路径为 /api/ 开头的请求代理到本服务器的 7001 端口服务，这里也可以填写其他的服务器
  }
}
```

如果要学习什么是正向代理什么是反向代理，我还没有整理，就先去我开始学习的博文 [前端开发如何独立解决跨域问题](https://segmentfault.com/a/1190000010719058)