词法作用域（静态作用域）：函数的作用域在函数定义的时候就决定了。

动态作用域：函数的作用域是在函数调用的时候才决定的。

JavaScript 使用的是词法作用域，js 代码运行如下：

```
var a = 1;
function foo() {
  console.log(a);
}

function bar() {
  var a = 2;
  foo();
}
bar(); // 打印出来的是 1
```

## VO/AO（不是很懂，内容来之后文链接中的内容）

VO：变量对象，是由形参、声明的函数、声明的变量组成

AO：是 VO 的引用，它是 VO 中的一个自我引用的属性

```
global = {
  Math: <...>,
  String: <...>
  ...
  ...
  window: global //引用自身
};
```

只有全局变量对象允许通过 VO 的属性名称来间接访问，在其它上下文中是不能直接访问VO对象的，因为它只是内部机制的一个实现

当进入执行上下文(代码执行之前)时，VO里已经包含了形参、函数声明、变量声明

```
function test(a, b) {
  var c = 10;
  function d() {}
  var e = function _e() {};
  (function x() {});
}
 
test(10);
```

```
AO(test) = {
  a: 10,
  b: undefined,
  c: undefined,
  d: <reference to FunctionDeclaration "d">
  e: undefined
};
```



```
alert(x); // function
 
var x = 10;
alert(x); // 10
 
x = 20;
 
function x() {};
 
alert(x); // 20
```

根据规范函数声明是在当**进入上下文**时填入的； 同一周期，在进入上下文的时候还有一个变量声明“x”，变量声明在顺序上跟在函数声明和形式参数声明之后，而且在这个**进入上下文**阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明，因此，在进入上下文时，VO的结构如下：

```
VO = {};
 
VO['x'] = <reference to FunctionDeclaration "x">
 
// 找到var x = 10;
// 如果function "x"没有已经声明的话
// 这时候"x"的值应该是undefined
// 但是这个case里变量声明没有影响同名的function的值
 
VO['x'] = <the value is not disturbed, still function>
```

学习文章：

[变量对象](https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html)