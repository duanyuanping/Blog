## 首屏加载
1. loading
  - 给页面中添加loading状态，避免页面元素渲染过程一直处于白屏
  - 使用`html-webpack-plugin`插件中的loading属性，传入loading图片，当页面还在处理的时候，显示loading图片
2. 静态渲染服务器（JAMStack）
  - 服务端在构建过程，就将html静态页面生成出来，等用户访问的时候，直接将html返回给客户端（博客网站）
  - gatsby构建的博客网站，项目中不经常变化的页面同样可以使用这项技术
3. 服务端渲染（ssr）
  - 客户端请求页面服务器资源，服务器在本地加载页面首屏数据，然后使用react服务端渲染技术，将数据转换成html，然后在插入到html模版文件中，再将html返回给客户端，客户端拿到html页面后，可以直接将带有首屏html的文档渲染
4. http2
  - 帧传输：http头阻塞问题得到解决
  - 多路复用：减少tcp连接时间
  - http头压缩：两端都维护一张头部表，只传输内容更新了的头部信息
  - 服务端推送：可以根据客户端请求的html，将后续页面渲染需要的css和js主动推送给客户端
5. 浏览器缓存
  - 浏览器优先使用本地有效的缓存资源
  - react等第三方插件与业务代码分开打包（webpack中的splitChunks配置），并对最终打包出来的文件名中添加hash，对第三方插件打包资源添加`cache-control`，让浏览器该资源进行缓存
6. 骨架图（Skeleton）替换loading
  - 在页面中组件还没有渲染出来的时候，使用组件骨架图来替换loading，进行页面展示
![](https://segmentfault.com/img/remote/1460000020690108?w=275&h=469)
7. Tree Shaking
  - 使用打包工具自动筛除页面中无用代码，减少js代码文件体积，提升js文件加载和解析效率
8. polyfill动态加载
  - 直接引用`<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>`这个sdk，polyfill服务商会根据客户端浏览器user agent，识别客户端操作系统及版本、cpu、浏览器及版本等信息，然后根据这些信息来判断浏览器是否需要加载polyfill

## 组件
1. 组件懒加载
  - 页面中的组件按需加载，当前不影响页面使用的组件，等到需要使用的时候才进行加载。比如点击页面中的btn按钮，展示A组件，在页面加载过程中，先不加载A组件代码代码，等到btn点击的时候再去加载A组件
  - 优化首屏页面渲染效率
2. 组件预加载
  - 页面加载完成以后，组件使用进行懒加载，如果A组件代码很大，加载需要2s，那么在点击btn后，需要等2s才能使用A组件。其实在页面加载渲染完成以后，在用户点击btn前，浏览器还是存在一定的空闲时间，这段时间什么也没干，我们可以在这段空闲时间离将A组件代码加载到浏览器本地，等到用户点击btn后，直接使用本地的A组件代码，将A组件渲染出来
  - 优化组件懒加载效率

## 其他
1. 图片懒加载
2. 资源压缩
3. cdn
4. 雪碧图
5. css资源放在js资源前
