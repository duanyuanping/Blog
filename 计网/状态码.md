

## 1*



## 2*

### 200

请求没问题，响应的实体包含了所有请求的资源

### 204

请求没问题，但是没有内容响应给浏览器，及响应体中没有实体部分

### 206

## 3*（重定向）

### 301

在 HTTP1.0 和 HTTP 1.1 中都代表永久重定向，原来的 url 替换成 301 响应体中的 location 属性值的 url 然后再进行请求。

规范：对于 post 请求重定向，需要用户确定之后才能够重定向，并且以 post 方式发起重定向请求。

浏览器实现：在实际中并没有实现 post 重定向向用户确认的问题；

在资源路径修改之后 SEO 不会出现问题

### 302

在 HTTP1.0 中表示临时重定向，客户端应该使用 location 提供的 url 来临时定位资源。将来的请求仍然使用老的 url。

规范：原请求是 post，不能自动重定向；原请求是 get，可以自动进行重定向

浏览器实现：浏览器并没有像规范中那样实现，实际原请求即便是 post 请求，浏览器也会自动重定向。由此衍生了 302 劫持。HTTP1.1 中将 302 细化成 303 和 307，来消除规范与实现不一致的问题。

302 劫持：A 站通过重定向到 B 站的资源 S，对于搜索引擎而言，他一般自会去抓取 B 站中的内容。但是如果 A 有一个比较友好的域名，而 B 站的域名并不是那么友好，那么浏览器此时很有可能显示的地址是 A 站的 url ，但是内容确实 B 站中的 S 内容，这就导致 B 的内容、带宽、服务器等资源全部让 A 拿去了

### 303

HTTP1.1 规范中 302 分化的一个方向，原请求不管是 get 还是 post 都允许重定向。

### 304

告知浏览器中验证的缓存没有过期，响应不应该含有响应体

### 307

HTTP1.1 规范中 302 分化的一个方向，原请求不是 get 或者 head 方式，浏览器一定不能自动重定向。

### 3* 总结

301 和 302 都是 HTTP1.0 中规定的状态码，303 和 307 是 HTTP1.1 中新规定的状态码。303 和 307 是由 302 分化出来的，用于解决 302 规范和浏览器实现的不一致的问题。

## 4*（请求错误）

### 400

请求报文中存在语法错误或者参数错误，服务器不能理解

### 401

请求用户信息认证失败，和未登录差不多

### 403

请求被服务器拒绝，可能因为权限或者限时的原因等等，服务器在响应体中说明拒绝的原因。

### 404

服务器无法找到请求的 url（无法找到请求的资源）

### 405

使用请求的 url 不支持的方式请求（allow 会给出哪些是允许的请求方式）

## 5*（服务器错误）

### 500 

服务器处理请求的时候出错，可能是由于程序中的 bug

### 503

服务器超负荷或者正停机维护中，无法处理请求，将来可以。如果服务器知道还需要多久才能正常运行，就写入 Retry-After 手表字段返回

