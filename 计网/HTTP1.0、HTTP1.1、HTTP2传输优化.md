## HTTP1.1 相对于 HTTP1.0

### 持久连接

重用已经建立好了的连接，减少三次握手的发送延时，浏览器在请求时带上 `connection: keep-alive` 的头部，服务器收到后就要发送完响应后保持连接一段时间，浏览器在下一次对该服务器的请求时，就可以直接拿来用。

![](https://box.kancloud.cn/2015-10-27_562ee2c92d1e7.jpg)

（内容和图片都来自 https://www.kancloud.cn/digest/web-performance-http2/74822）

### 管线化

建立在持久连接之上，是把所有请求一并发给服务器，但是服务器需要按照顺序一个一个响应，而不是等到一个响应回来才能发下一个请求，这样就节省了很多请求到服务器的时间。不过，HTTP管线化仍旧有阻塞的问题，若上一响应迟迟不回，后面的响应都会被阻塞到。

![](https://box.kancloud.cn/2015-10-27_562ee2c94c136.jpg)

（内容和图片都来自 https://www.kancloud.cn/digest/web-performance-http2/74822）

### bigpipe

目前大部分模型都是，服务器把逻辑处理完之后，一次性把整个响应输出，如果页面包含多个较独立部分，也可以每处理完一部分就马上输出，这样可以缩短白屏

## HTTP2 和 HTTP1.0

### 多路复用

多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息

![](https://pic2.zhimg.com/80/b1e608ddb7493608efea3e76912aabe1_hd.png)

（图片来自 https://www.zhihu.com/question/34074946）

“流”在HTTP/2中是一个逻辑上的概念，就是说在一个TCP连接上，我们可以向对方不断发送一个个的消息，这里每一个消息看成是一帧，而每一帧有个stream identifier的字段标明这一帧属于哪个“流”，然后在对方接收时，根据stream identifier拼接每个“流”的所有帧组成一整块数据

流的优先级：

web 优化的时候一般把图片延迟加载，目的是除了节省流量外，还能避免图片资源与其他重要的脚本资源竞争下载，HTTP/2提供了流的优先级与依赖性这种机制。

### 服务器推送

服务器对同一请求可以推送多个响应。

服务器在接受到请求时，分析出要推送的资源，先发个 `PUSH_PROMISE` 帧给浏览器，此帧包含一个新的流ID，还有header block fragment字段，内容是请求的头部信息。

浏览器收到 `PUSH_PROMISE` 帧时，根据header block fragment字段里的url，可以知道当前有没有缓存，从而判断是否要接收。如果不要，浏览器就要发送个 `RST_STREAM` 来终止服务器推送

### 首部压缩

在HTTP/1.x中首部是没有压缩的，gzip只会压缩body，HTTP/2提供了首部压缩方案，首部压缩使得整个HTTP数据包小了很多，传输也就会更快。