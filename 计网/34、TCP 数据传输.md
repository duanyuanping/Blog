[TCP握手挥手](https://zhuanlan.zhihu.com/p/53374516)

## 三次握手
- SYN：连接序列号
- seq（ISN）：客户端初始序列号
- ACK：确认客户端的序列号（seq+1）

1. 第一次握手：
- 客户端发送 SYN（连接序列号）
- ack（确认号）：0
- seq（客户端初始序列号）：x

2. 第二次握手
- 服务器端发送 SYN
- seq：y
- ack：x + 1

3. 第三次握手
- ack：y + 1

为什么需要三次握手？  
服务端和客户端确认对方接收和发送数据功能是否正常。
- 第一次握手，客户端给服务端发送连接信息。服务端收到信息，服务端就知道客户端有发送数据的能力，服务端有接收数据的能力
- 第二次握手，服务端给客户端发送连接信息。客户端收到信息，客户端就知道服务端有接收数据和发送数据的能力，客户端有接收数据和发送数据的能力
- 第三次握手，客户端给服务端发送连接信息。服务端收到消息，服务端知道客户端有接收数据的能力，服务端有发送数据的能力（因为第二次服务端发送的数据客户端收到了）

## 四次挥手

![](https://user-gold-cdn.xitu.io/2018/6/26/1643a20296de1ff0?imageslim)

（图片来源 https://juejin.im/post/5b29d2c4e51d4558b80b1d8c）

1. 客户端发送 fin(m) 包，客户端进入 fin-wait-1，表明客户端已经没有数据发送了
2. 服务器端收到客户端发送的 FIN(M) 包后，向客户端发送一个 ack(m + 1) 包，服务器端进入 close-wait，客户端进入 fin-wait-2
3. 服务器端向客户端发送 fin(n) 包，请求关闭连接，服务器端进入 last-ack
4. 客户端收到服务器的 fin(n) 包，进入 time-wait。向服务器端发送 ack(n+1)，服务器端收到客户端的 ack(n+1) 包后，进入 close；客户端等待一段时间（规定是4分钟，实际中可以改动）没有得到服务器端回复，进入 close。

为什么需要四次挥手？  
当连接双方某一方发送fin数据（即断开连接），我们这里以客户端发出fin数据为例，服务端发送ack给客户端确认号，此时，只是断开了客户端给服务端发送数据的能力（这里断开数据发送的能力是指应用层没办法再发数据了，实际存在的链路还是可以继续发送数据给服务端），而服务端给客户端发送数据的链路并没有断开，一次服务端依旧可以给客户端发送数据。后续服务端发送fin数据给客户端时，此时客户端将ack发送给服务端，到此，整个tcp连接断开，无法发送数据。

注意fin数据发送方断开数据发送能力，指的是发送方应用层不能再发数据了，而原链路还是存在的，tcp依旧可以使用该链路发送ack数据等信息。

## TCP 传输

### 可靠传输

客户端发送第一个数据包，服务器收到客户端传来得数据包后，需要发送一个确认收到的数据包给客户端，客户端等待服务器端返回确认收到的数据包，如果在有效的时间内客户端收到了确认包后，就发第二个数据包，如果客户端到了等待的最长时间还没有收到服务器的确认数据包，那就重新传第一个数据包。

去重：服务器返回的确认包太慢了，客户端又重新发了一次第一个数据包，服务器这边直接把重复的扔掉，然后重新发送一个确认收到的包

### 流水线传输（窗口技术）

![](http://testduan.oss-cn-beijing.aliyuncs.com/blog-img/%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93.jpg)

实际应用中的 TCP 传输是客户端会连续发送多个数据包，然后服务器端接收到以后返回确认包就行了，这样就提高了信道利用率。

客户端可以连续发送多少个数据包呢？这个需要客户端和服务器端商量好合适的发送速率和接收速率，这就是 TCP 窗口大小

累计确认：服务器端将收到的连续的数据包确认号发送个客户端（如：服务器端收到了1,2,3数据包，那就返回 3 确认号，客户端收到 3 确认号后，就知道服务器端1,2,3都接收到了，然后发4；如果服务器端收到1,2,4数据包，就返回2确认号，这样客户端就会重新发3及其以后的数据包）
