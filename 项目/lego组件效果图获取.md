## 总体流程
1. 配置组件调用的属性配置文件
2. 向远程仓库推送代码，触发pre-push钩子，运行后置脚本
3. 运行构建代码，生成效果图页面
4. 将构建的网页内容发布到线网
5. 发布完成以后，执行后置脚本，请求截图服务并将本次更新的页面线上地址带过去
6. 请求本次更新的组件效果图页面，使用puppeteer截取每个效果图节点图片
7. 图片去重、图片入库

## 1.配置文件
配置文件会返回一个json数据，该json数据由组件调用的必要和非必要参数构成。

## 2.钩子触发
当master push事件触发，会触发git中push webhooks，当push钩子触发时，git仓库会请求公司内部的ci工具（oci），让ci工具根据指令文件执行相关内容。

在ci中能够获取当前mr中更新的文件，当运行构建后置脚本的时候，我们通过命令行参数的形式将更新的文件列表传入。后置脚本拿到更新列表后，将文件以组件维度分类，获取当前更新的组件有哪些。获取到列表后，依次执行构建脚本。

>为什么不用本地的git hooks？  
1、组件仓库时分支开发，只有当代码合入master才能算作组件发布（不能使用分支发布的代码，这样可能会导致用户使用的组件版本和组件效果图展现不一致的情况），而将代码合入master是在git仓库中完成的动作，这里没办法直接执行项目下的脚本。  
2、构建出来的页面上线会有问题。团队项目上线需要将代码包上传到织云上，本地开发网络和织云网络存在网络隔离问题。

## 3.运行构建代码
将效果图模板代码复制到对应组件的缓存文件中，将模板文件中的配置文件锚点替换成配置文件地址。运行build构建组件效果页面。

为了尽可能获取组件可以展示的效果，构建页面中会根据配置文件中的设置，将属性分为必要参数和非必要参数两类，然后将非必要参数进行组合，获取所有可能，然后在组件调用的时候传入，这样就获得了该组件所有可能的效果。同时每个效果节点中都设置了当前传入了什么参数，以便后面截图的时候将这些效果与传参对应上。

构建完成之后，将本次组件构建的最终代码复制到发布文件中，以便oci只发布一次文件。

## 4.发布线网
这里我们依靠oci来帮我们将所有构建结果发布到织云线网服务器上，发布成功以后我们就可以在线网访问到组件的效果页面了。

## 5.发布完成，执行后置脚本
页面发布完成后，oci会执行事先设置的后置脚本，同时将本次仓库更新的文件列表带上。后置脚本中，通过文件列表获取到本次更新的组件有哪些，然后将这些组件的线上效果页面拼接出来，请求截图服务。

## 6.截图服务
这里借助的puppeteer无头浏览器访问组件的效果图页面，当页面中所有内容都加载完成以后，即domContentLoaded事件触发（无头浏览器参数`await page.goto(url, {waitUntil: 'domcontentloaded'})`）时，获取所有效果节点，然后执行节点对象的`screenshot`函数，这样就完成了节点截图。

在获取到截图以后，我们还需要获取效果节点中的传参，将效果和传参一一对应上，以便后续展示效果的时候能够告诉开发者，如果想要组件产生这种效果，需要传入什么参数。

## 图片去重、图片上传
由于组件的所有效果都是随机生成的，组件传入不同的参数后，展示效果可能一样，因此需要将图片去重。代码中使用`pixelmatch`工具对图片进行像素级比较，如果图片相同，就删除其中一张。

>图片去重优化方案(todo)：  
获取图片的rgb（使用get-pixels获取图片像素rgb值），生成直方图，然后计算方差，再比较各个图片直方图的方差，判断是否是同样效果的图片。  
这样做比每次都使用`pixelmatch`工具比较两张图片的方式要快很多。

图片去重以后，对图片进行压缩操作，将图片上传到静态资源服务器，然后将图片和组件调用参数入库。
